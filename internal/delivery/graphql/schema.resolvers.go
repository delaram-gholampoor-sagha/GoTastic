package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/delaram/GoTastic/internal/delivery/graphql/model"
	"github.com/delaram/GoTastic/internal/domain"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, description string, dueDate time.Time, fileID *string) (*model.Todo, error) {
	var fid string
	if fileID != nil {
		fid = *fileID
	}
	todo, err := r.TodoUC.CreateTodoItem(ctx, description, dueDate, fid)
	if err != nil {
		return nil, err
	}
	return toModelTodoPtr(todo), nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, id string, description string, dueDate time.Time, fileID *string) (*model.Todo, error) {
	var fid *string
	if fileID != nil && *fileID != "" {
		fid = fileID
	}

	// Build a minimal domain object using UUID (not numeric ID)
	t := &domain.TodoItem{
		UUID:        id,
		Description: description,
		DueDate:     &dueDate, // <-- pointer to time
		FileID:      fid,      // *string (may be nil)
	}

	if err := r.TodoUC.UpdateTodoItem(ctx, t); err != nil {
		return nil, err
	}

	after, err := r.TodoUC.GetTodoItem(ctx, id)
	if err != nil {
		return nil, err
	}
	return toModelTodoPtr(after), nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (bool, error) {
	if err := r.TodoUC.DeleteTodoItem(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload) (string, error) {
	return r.FileUC.UploadFile(ctx, file.File, file.Filename)
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (bool, error) {
	if err := r.FileUC.DeleteFile(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "ok", nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, page model.PageInput, filter *model.TodoFilter, sort *model.TodoSort) (*model.TodoPage, error) {
	// guardrails
	if page.Limit <= 0 || page.Limit > 100 {
		page.Limit = 20
	}
	if page.Offset < 0 {
		page.Offset = 0
	}

	// translate filter/sort to domain types
	df := domain.TodoFilter{}
	if filter != nil {
		df.Q = filter.Q
		df.DueFrom = filter.DueFrom
		df.DueTo = filter.DueTo
		df.HasFile = filter.HasFile
	}

	ds := domain.TodoSort{Field: domain.SortUpdatedAt, Direction: domain.SortDesc}
	if sort != nil {
		switch sort.Field {
		case model.TodoSortFieldCreatedAt:
			ds.Field = domain.SortCreatedAt
		case model.TodoSortFieldDueDate:
			ds.Field = domain.SortDueDate
		case model.TodoSortFieldUpdatedAt:
			ds.Field = domain.SortUpdatedAt
		case model.TodoSortFieldDescription:
			ds.Field = domain.SortDescription
		}
		if sort.Direction == model.SortDirectionAsc {
			ds.Direction = domain.SortAsc
		} else {
			ds.Direction = domain.SortDesc
		}
	}

	items, total, err := r.TodoUC.ListTodoItemsPaged(ctx, df, ds, page.Limit, page.Offset)
	if err != nil {
		return nil, err
	}

	return &model.TodoPage{
		Total: int(total),
		Items: toModelTodosPtr(items),
	}, nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string) (*model.Todo, error) {
	item, err := r.TodoUC.GetTodoItem(ctx, id)
	if err != nil {
		return nil, err
	}
	return toModelTodoPtr(item), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
